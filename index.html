<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
      Bollard Buddy AR - map street safety devices in the field using AR
    </title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" href="/style.css" />
    <link rel="stylesheet" href="/play.css" />

    <!-- IMPORTANT: PLACE YOUR SDK SCRIPT TAG BELOW IF FORKING  -->
    <script src="https://launchar.app/sdk/v1?key=vDhrPJN2RAYrTKXak3LYKFPnPGKYAzKK&redirect=true"></script>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="json-crush.js"></script>
    <script src="ar-helpers.js"></script>
    <script src="mini-serialize.js"></script>
    <script src="segment-display.js"></script>
    <script>
      // Canvas-based measurement display component for AR
      AFRAME.registerComponent('canvas-measurement-display', {
        schema: {
          value: { type: 'string', default: '0.00' },
          width: { type: 'number', default: 200 },
          height: { type: 'number', default: 60 }
        },
        init: function () {
          this.canvas = document.createElement('canvas');
          this.canvas.width = this.data.width;
          this.canvas.height = this.data.height;
          
          // Create segment display instance
          this.display = new SegmentDisplay(this.canvas.id);
          this.display.pattern = "###.##";
          this.display.cornerType = SegmentDisplay.RoundedCorner;
          this.display.displayAngle = 0;
          this.display.digitHeight = 40;
          this.display.digitWidth = 24;
          this.display.digitDistance = 3;
          this.display.segmentWidth = 4;
          this.display.segmentDistance = 0.5;
          this.display.colorOn = "rgba(255, 255, 0, 0.9)";
          this.display.colorOff = "rgba(255, 255, 0, 0.1)";
          
          // Create texture and material
          this.texture = new THREE.CanvasTexture(this.canvas);
          this.texture.needsUpdate = true;
          
          this.material = new THREE.MeshBasicMaterial({
            map: this.texture,
            transparent: true,
            alphaTest: 0.1,
            side: THREE.DoubleSide
          });
          
          // Create plane geometry
          const geometry = new THREE.PlaneGeometry(0.4, 0.12);
          this.mesh = new THREE.Mesh(geometry, this.material);
          this.el.setObject3D('mesh', this.mesh);
          
          this.updateDisplay();
        },
        update: function () {
          this.updateDisplay();
        },
        updateDisplay: function () {
          // Format value to ###.## pattern
          const numValue = parseFloat(this.data.value) || 0;
          const formattedValue = numValue.toFixed(2).padStart(6, ' ');
          
          // Update canvas directly since we don't have DOM element
          const context = this.canvas.getContext('2d');
          context.clearRect(0, 0, this.canvas.width, this.canvas.height);
          
          // Set canvas as display element temporarily
          const tempId = 'temp-display-' + Math.random().toString(36).substr(2, 9);
          this.canvas.id = tempId;
          document.body.appendChild(this.canvas);
          this.canvas.style.display = 'none';
          
          this.display.displayId = tempId;
          this.display.setValue(formattedValue);
          
          // Clean up
          document.body.removeChild(this.canvas);
          this.canvas.id = '';
          
          this.texture.needsUpdate = true;
        },
        remove: function () {
          if (this.material) {
            this.material.dispose();
          }
          if (this.texture) {
            this.texture.dispose();
          }
        }
      });

      // Simplified measure line component for Bollard Buddy
      AFRAME.registerComponent('measure-line', {
        schema: {
          start: { type: 'vec3', default: { x: 0, y: 0, z: 0 } },
          end: { type: 'vec3', default: { x: 0, y: 0, z: 0 } }
        },
        init: function () {
          this.tmpQuaternion = new THREE.Quaternion();
          this.direction = new THREE.Vector3();
          this.radius = 0.025;
          this.color = 0xffff00;
          this.endpointRadius = 0.075;
          this.startColor = 0x00ff00;
          this.endColor = 0xff0000;
          
          // Create canvas-based measurement display for AR compatibility
          this.labelEntity = document.createElement('a-entity');
          this.labelEntity.setAttribute('canvas-measurement-display', {
            value: '0.00'
          });
          this.el.appendChild(this.labelEntity);
        },
        update: function () {
          this.createOrUpdateHelper();
        },
        createOrUpdateHelper: function () {
          const start = this.data.start;
          const end = this.data.end;
          const length = this.calculateLength();
          
          // Create cylinder geometry
          const geometry = new THREE.CylinderGeometry(this.radius, this.radius, length, 8);
          
          if (!this.mesh) {
            const material = new THREE.MeshBasicMaterial({
              color: this.color,
              transparent: true,
              opacity: 0.7,
              depthTest: false
            });
            this.mesh = new THREE.Mesh(geometry, material);
            this.el.setObject3D('helper', this.mesh);
          } else {
            this.mesh.geometry.dispose();
            this.mesh.geometry = geometry;
          }
          
          // Position at midpoint
          this.mesh.position.set(
            (start.x + end.x) / 2,
            (start.y + end.y) / 2,
            (start.z + end.z) / 2
          );
          
          // Rotate to align with direction
          const up = new THREE.Vector3(0, 1, 0);
          this.direction.set(end.x - start.x, end.y - start.y, end.z - start.z).normalize();
          this.tmpQuaternion.setFromUnitVectors(up, this.direction);
          this.mesh.setRotationFromQuaternion(this.tmpQuaternion);
          
          this.createOrUpdateEndpoints(start, end);
          this.updateLabel(length);
        },
        createOrUpdateEndpoints: function (start, end) {
          const sphereGeometry = new THREE.SphereGeometry(this.endpointRadius, 16, 16);
          
          if (!this.startEndpoint) {
            const startMaterial = new THREE.MeshBasicMaterial({
              color: this.startColor,
              transparent: true,
              opacity: 0.8,
              depthTest: false
            });
            this.startEndpoint = new THREE.Mesh(sphereGeometry, startMaterial);
            this.el.setObject3D('startEndpoint', this.startEndpoint);
          }
          this.startEndpoint.position.set(start.x, start.y, start.z);
          
          if (!this.endEndpoint) {
            const endMaterial = new THREE.MeshBasicMaterial({
              color: this.endColor,
              transparent: true,
              opacity: 0.8,
              depthTest: false
            });
            this.endEndpoint = new THREE.Mesh(sphereGeometry, endMaterial);
            this.el.setObject3D('endEndpoint', this.endEndpoint);
          }
          this.endEndpoint.position.set(end.x, end.y, end.z);
        },
        updateLabel: function (length) {
          // Update canvas-based display value
          this.labelEntity.setAttribute('canvas-measurement-display', {
            value: length.toFixed(2)
          });
          
          // Position label at midpoint with offset
          const midpoint = new THREE.Vector3(
            (this.data.start.x + this.data.end.x) / 2,
            (this.data.start.y + this.data.end.y) / 2 + 0.3,
            (this.data.start.z + this.data.end.z) / 2
          );
          
          this.labelEntity.setAttribute('position', midpoint);
          
          // Make label always face the camera
          const camera = this.el.sceneEl.camera;
          if (camera) {
            this.labelEntity.setAttribute('look-at', camera);
          }
        },
        calculateLength: function () {
          const start = this.data.start;
          const end = this.data.end;
          const xDiff = end.x - start.x;
          const yDiff = end.y - start.y;
          const zDiff = end.z - start.z;
          return Math.sqrt(xDiff * xDiff + yDiff * yDiff + zDiff * zDiff);
        },
        remove: function () {
          if (this.mesh) {
            this.mesh.material.dispose();
            this.mesh.geometry.dispose();
          }
          if (this.startEndpoint) {
            this.startEndpoint.material.dispose();
            this.startEndpoint.geometry.dispose();
          }
          if (this.endEndpoint) {
            this.endEndpoint.material.dispose();
            this.endEndpoint.geometry.dispose();
          }
          if (this.labelEntity) {
            this.labelEntity.remove();
          }
        }
      });
    </script>
    <!-- <script src="https://unpkg.com/3dstreet@0.4.11/dist/aframe-street-component.js"></script> -->
    <script src="play.js"></script>

    <!-- <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-particle-system-component@1.1.4/dist/aframe-particle-system-component.min.js"></script> -->
  </head>
  <body>
    <a-scene
      vr-mode-ui="enterARButton: #play-button"
      device-orientation-permission-ui="enabled: false"
      webxr="requiredFeatures:hit-test,local-floor,dom-overlay;referenceSpaceType:local-floor;overlayElement:#overlay"
      metadata="lat: 37.766194; long: -122.412989; elevation: -26.5; title: AR Session Entities โข Treat AR App"
      notify
    >
      <a-assets>
          <a-mixin
            shadow
            id="dividers-k71"
            gltf-model="src: url(https://assets.3dstreet.app/sets/uoregon/gltf-exports/draco/traffic-post-k71.glb)"
          ></a-mixin>
          <a-mixin
            shadow
            id="landscape-sunflower"
            gltf-model="src: url(https://cdn.glitch.me/b37e506f-65c9-49b0-b29e-ba5c75b8d553/sunflower.glb?v=1711151552432)"
          ></a-mixin>

          <a-mixin
          shadow
          id="temporary-traffic-cone"
          gltf-model="src: url(https://assets.3dstreet.app/sets/dividers/gltf-exports/draco/dividers-traffic-cone.glb)"
        ></a-mixin>

          <a-mixin
          shadow
          id="dividers-flowers"
          gltf-model="src: url(https://assets.3dstreet.app/sets/dividers/gltf-exports/draco/dividers-flowers.glb)"
        ></a-mixin>

          <a-mixin
          shadow
          id="bollard"
          gltf-model="src: url(https://assets.3dstreet.app/sets/dividers/gltf-exports/draco/dividers-bollard.glb)"
        ></a-mixin>

          <a-mixin
          shadow
          id="safehit"
          gltf-model="src: url(https://assets.3dstreet.app/sets/dividers/gltf-exports/draco/dividers-safehit.glb)"
        ></a-mixin>      
      </a-assets>
      <a-entity exit-ar-button="element: #exit-ar" hide-in-ar-mode></a-entity>
      <a-camera position="0 1.2 6"></a-camera>
      <a-ring
        id="reticle"
        ar-hit-test-simple
        rotation="-90 0 0"
        radius-inner="0.02"
        radius-outer="0.03"
      >
        <a-ring
          color="yellow"
          radius-inner="0.04"
          radius-outer="0.05"
          animation="property: scale; from: 1 1 1; to: 2 2 2; loop: true; dir: alternate"
        ></a-ring>
        <a-ring
          color="yellow"
          radius-inner="0.06"
          radius-outer="0.07"
          animation="property: scale; from: 1 1 1; to: 3 3 3; loop: true; dir: alternate"
        ></a-ring>
      </a-ring>
      <!-- Environment for 2D and VR viewing. It's auto-hidden in AR mode. -->
      <a-entity
        environment="preset: forest; lighting: none; shadow: none; lightPosition: 0 2.15 0"
        hide-in-ar-mode
      ></a-entity>

      <a-entity id="parent"></a-entity>

      <a-entity light="type: ambient; intensity: 0.5;"></a-entity>
      <a-light
        type="directional"
        light="castShadow: true;
                      shadowMapHeight: 1024;
                      shadowMapWidth: 1024;
                      shadowCameraLeft: -7;
                      shadowCameraRight: 5;
                      shadowCameraBottom: -5;
                      shadowCameraTop: 5;"
        id="light"
        target="model"
        position="-5 3 1.5"
      ></a-light>

      <!-- This shadow-receiving plane is only visible in AR mode. -->
      <a-plane
        height="15"
        width="15"
        position="0 0 0"
        rotation="-90 0 0"
        shadow="receive: true"
        ar-shadows="opacity: 0.3"
        visible="false"
        id="shadow-plane"
      ></a-plane>
    </a-scene>

    <div id="overlay" draggable="false">
      <span id="greeting"> Bollard Buddy AR from 3DStreet </span>
      <button id="exit-ar">SHARE and exit AR mode</button>
      <div
        id="play-button"
        onclick="compassPermission();"
        class="play-button"
      ></div>

      <div class="bottom-menu">
        <p>
          Selected item:
          <span id="selectedModel"><b>temporary-traffic-cone</b></span
          >; Compass: <span id="compass">x</span> <span id="tracking"></span>
        </p>
        <div id="menu" class="scrolling-wrapper">
          <!-- Menu buttons will be generated dynamically -->
        </div>
      </div>
    </div>

    <div id="text">
      <div class="header-layout">
        <img src="3D-St-stacked-128.png" alt="3D Street Logo" class="logo-3dstreet" />
        <img src="buddy.png" alt="Bollard Buddy Logo" class="logo-buddy" />
        <h1>Bollard Buddy:<br/>Place, Measure, View in AR</h1>
      </div>
      <p>An app from <a href="https://3dstreet.com" target="_blank">3DStreet</a>. For mobile WebXR compatible devices and browsers. Orientation default is North (-z)</p>
    </div>

    <div id="post" style="visibility: hidden">
      <h1>Bollard Buddy AR</h1>
      <h2>Wow beautiful creation! Here's a magic link for sharing:</h2>
      <input type="text" id="shareLink" name="shareLink" />
      <h1>
        <button id="share">SHARE</button>
      </h1>
    </div>
    <script>
      function compassPermission() {
        if (
          typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function"
        ) {
          // (optional) Do something before API request prompt.
          DeviceOrientationEvent.requestPermission()
            .then((response) => {
              // (optional) Do something after API prompt dismissed.

              if (response == "granted") {
                window.addEventListener("deviceorientation", (e) => {
                  // do something for 'e' here.

                  // log(e.alpha);
                  // console.log(e);

                  var compassHeading = 360 - e.alpha;
                  document.getElementById("compass").textContent =
                    compassHeading.toFixed(3) + "ยบ";
                  // DeviceOrientationEvent
                  //                    log(Math.round(event.alpha));
                  // log(Math.round(event.beta));
                  // log(Math.round(event.gamma));
                });
              }
            })
            .catch(console.error);
        } else {
          alert("DeviceMotionEvent is not defined");
        }
      }
      
      window.addEventListener('vlaunch-initialized', (event) => {
        console.log('vlaunch-initialized', event);
        if (event.detail.browser === "launch-viewer") {

          // Debug: Test if the element exists
          setTimeout(() => {
            const trackingElement = document.getElementById('tracking');
            console.log('Tracking element found:', trackingElement);
            if (trackingElement) {
              trackingElement.textContent = 'Tracking: Initializing...';
            }
          }, 1000);
          
          // Add tracking quality event listener
          window.addEventListener('vlaunch-ar-tracking', function(event) {
            console.log('vlaunch-ar-tracking event received:', event);
            console.log('Event detail:', event.detail);
            
            const trackingStatus = event.detail.status;
            const trackingElement = document.getElementById('tracking');
            
            if (trackingElement) {
              // Display the tracking state
              trackingElement.textContent = 'Tracking: ' + trackingStatus;
            }
            console.log('Tracking quality changed:', trackingStatus);
          });
        }
        // then show tracking events
        
      })
      
      function getTrackingColor(state) {
        switch (state) {
          case 'normal':
            return '#00ff00'; // Green for good tracking
          case 'not-available':
            return '#ff0000'; // Red for no tracking
          case 'limited-excessive-motion':
          case 'limited-initializing':
          case 'limited-insufficient-features':
          case 'limited-relocalizing':
            return '#ffaa00'; // Orange for limited tracking
          default:
            return '#ffffff'; // White for unknown
        }
      }
    </script>
    <script>
      window.POINTERDOWN_STATUS = false; // default is false
      window.MEASURE_STATE = { 
        isActive: false, 
        startPoint: null, 
        currentMeasure: null 
      };
      
      function handleMeasureClick(position) {
        if (!window.MEASURE_STATE.isActive) {
          // First click - create measure line and set start point
          window.MEASURE_STATE.isActive = true;
          window.MEASURE_STATE.startPoint = {x: position.x, y: position.y, z: position.z};
          
          const measureId = "measure-" + Date.now();
          const measureEntity = document.createElement("a-entity");
          measureEntity.setAttribute("id", measureId);
          measureEntity.setAttribute("measure-line", {
            start: window.MEASURE_STATE.startPoint,
            end: window.MEASURE_STATE.startPoint // Start with same point
          });
          
          document.getElementById("parent").appendChild(measureEntity);
          window.MEASURE_STATE.currentMeasure = measureEntity;
          
          console.log("Measurement started at:", position);
        } else {
          // Second click - finalize measurement
          const endPoint = {x: position.x, y: position.y, z: position.z};
          
          if (window.MEASURE_STATE.currentMeasure) {
            window.MEASURE_STATE.currentMeasure.setAttribute("measure-line", {
              start: window.MEASURE_STATE.startPoint,
              end: endPoint
            });
          }
          
          // Reset state
          window.MEASURE_STATE.isActive = false;
          window.MEASURE_STATE.startPoint = null;
          
          console.log("Measurement completed:", window.MEASURE_STATE.startPoint, "to", endPoint);
        }
      }
      function share() {
        if (navigator.share) {
          navigator
            .share({
              title: "Bollard Buddy AR Scene",
              text: document.getElementById("shareLink").value,
            })
            .then(() => console.log("Successful share"))
            .catch((error) => console.log("Error sharing:", error));
        }
      }
      document.getElementById("share").onclick = share.bind(this);

      function setSelected(mixin) {
        document.getElementById("selectedModel").textContent = mixin;
        console.log(this);
        // Get a list of all the elements with the class "my-class"
        const elements = document.querySelectorAll(".card");

        // Iterate over the list and remove the class from each element
        elements.forEach((element) => element.classList.remove("selected"));
        this.classList.add("selected");
      }

      // Data-driven menu configuration
      const menuItems = [
        { id: "temporary-traffic-cone", label: "Cone" },
        { id: "measure-line", label: "Measure" },
        { id: "bollard", label: "Bollard" },
        { id: "dividers-flowers", label: "Flowers" },
        { id: "safehit", label: "Delineator" },
        { id: "bench", label: "Bench" },
        { id: "lamp-traditional", label: "Lamp" },
        { id: "outdoor_dining", label: "Dining" }
      ];

      // Generate menu buttons dynamically
      const menuContainer = document.getElementById("menu");
      menuContainer.innerHTML = ""; // Clear existing buttons
      
      menuItems.forEach((item, index) => {
        const button = document.createElement("div");
        button.className = index === 0 ? "card selected" : "card";
        button.id = `btn_${index}`;
        button.innerHTML = `<h2>${item.label}</h2>`;
        button.onclick = setSelected.bind(button, item.id);
        menuContainer.appendChild(button);
      });
      document
        .getElementById("overlay")
        .addEventListener("pointerdown", (event) => {
          console.log("overlay-pointerdown");
          window.POINTERDOWN_STATUS = true;
          //   event.preventDefault();
        });
      document
        .getElementById("overlay")
        .addEventListener("pointerup", (event) => {
          console.log("overlay-pointerup");
          setTimeout(() => {
            window.POINTERDOWN_STATUS = false;
          }, 100);
        });
    </script>
    <script>
      <!-- https://github.com/stspanho/aframe-hit-test/blob/master/index.html -->
      AFRAME.registerComponent("ar-hit-test-simple", {
        init: function () {
          this.xrHitTestSource = null;
          this.viewerSpace = null;
          this.refSpace = null;

          this.el.sceneEl.renderer.xr.addEventListener("sessionend", (ev) => {
            this.viewerSpace = null;
            this.refSpace = null;
            this.xrHitTestSource = null;
          });
          this.el.sceneEl.renderer.xr.addEventListener("sessionstart", (ev) => {
            let session = this.el.sceneEl.renderer.xr.getSession();

            let element = this.el;
            session.addEventListener("select", function () {
              if (window.POINTERDOWN_STATUS) return;
              let position = element.getAttribute("position");
              document
                .getElementById("shadow-plane")
                .setAttribute("position", position);
              let newMixin =
                document.getElementById("selectedModel").textContent;
              
              if (newMixin === "measure-line") {
                handleMeasureClick(position);
                // Only show DONE button after completing measurement (second click)
                if (!window.MEASURE_STATE.isActive && window.MEASURE_STATE.currentMeasure) {
                  document.getElementById("text").style.visibility = "hidden";
                  document.getElementById("post").style.visibility = "visible";
                }
              } else {
                placeElement(newMixin, position);
                // set DONE button to visible
                document.getElementById("text").style.visibility = "hidden";
                document.getElementById("post").style.visibility = "visible";
              }

              // Wait for A-Frame to fully initialize objects before getting child entities data
              setTimeout(() => {
                // Get the uncrushed child entities data
                var dataString = getChildEntitiesInfo(
                  document.getElementById("parent")
                );

                const queryParams = new URLSearchParams(document.location.search);
                const sceneMetadata = document
                  .querySelector("a-scene")
                  .getAttribute("metadata");

                // Get lat/long/elevation from either query params or scene metadata
                const lat = queryParams.get("lat") || sceneMetadata.lat;
                const long = queryParams.get("long") || sceneMetadata.long;
                const elevation = queryParams.get("elevation") || sceneMetadata.elevation;

                // Build the scene data structure
                let sceneData = {
                  title: "Bollard Buddy Session",
                  version: "0.5.5",
                  data: [
                    {
                      id: "street-container",
                      "data-layer-name": "User Layers",
                      components: {},
                      children: [                  {
                      "data-layer-name": "Bollard Buddy Session",
                      components: {},
                      children: dataString
                    }]
                    }
                    // {
                    //   id: "environment",
                    //   "data-layer-name": "Environment",
                    //   components: {"street-environment": ""}
                    // },
                    // {
                    //   id: "reference-layers",
                    //   "data-layer-name": "Geospatial Layers",
                    //   components: {
                    //     "street-geo": `longitude: ${long}; latitude: ${lat}; orthometricHeight: ${elevation};`
                    //   }
                    // }
                  ]
                };
                
                // local dev
                // document.getElementById("shareLink").value =
                //   "http://localhost:3333/#crushed-3dstreet-json:" +
                //   encodeURIComponent(window.JSONCrush.crush(JSON.stringify(sceneData)));

                // production
                document.getElementById("shareLink").value =
                  "https://3dstreet.app/#crushed-3dstreet-json:" +
                  encodeURIComponent(window.JSONCrush.crush(JSON.stringify(sceneData)));
              }, 500);
            });

            session.requestReferenceSpace("viewer").then((space) => {
              this.viewerSpace = space;
              session
                .requestHitTestSource({ space: this.viewerSpace })
                .then((hitTestSource) => {
                  this.xrHitTestSource = hitTestSource;
                });
            });

            session.requestReferenceSpace("local-floor").then((space) => {
              this.refSpace = space;
            });
          });
        },
        tick: function () {
          if (!this.viewerSpace) return;

          let frame = this.el.sceneEl.frame;
          let xrViewerPose = frame.getViewerPose(this.refSpace);

          if (this.xrHitTestSource && xrViewerPose) {
            let hitTestResults = frame.getHitTestResults(this.xrHitTestSource);
            if (hitTestResults.length > 0) {
              let pose = hitTestResults[0].getPose(this.refSpace);

              let inputMat = new THREE.Matrix4();
              inputMat.fromArray(pose.transform.matrix);

              let position = new THREE.Vector3();
              position.setFromMatrixPosition(inputMat);
              this.el.setAttribute("position", position);
              
              // Update measure line end point if in measurement mode
              if (window.MEASURE_STATE.isActive && window.MEASURE_STATE.currentMeasure) {
                const endPoint = {x: position.x, y: position.y, z: position.z};
                window.MEASURE_STATE.currentMeasure.setAttribute("measure-line", {
                  start: window.MEASURE_STATE.startPoint,
                  end: endPoint
                });
              }
            }
          }
        },
      });
    </script>
  </body>
</html>
