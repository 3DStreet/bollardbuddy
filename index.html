<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
      Bollard Buddy AR - map street safety devices in the field using AR
    </title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" href="/style.css" />
    <link rel="stylesheet" href="/play.css" />

    <!-- IMPORTANT: PLACE YOUR SDK SCRIPT TAG BELOW IF FORKING  -->
    <script src="https://launchar.app/sdk/v1?key=vDhrPJN2RAYrTKXak3LYKFPnPGKYAzKK&redirect=true"></script>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="json-crush.js"></script>
    <script src="ar-helpers.js"></script>
    <script src="mini-serialize.js"></script>
    <script src="segment-display.js"></script>
    <script>
      // Canvas-based measurement display component for AR
      AFRAME.registerComponent('canvas-measurement-display', {
        schema: {
          value: { type: 'string', default: '0.00' },
          width: { type: 'number', default: 200 },
          height: { type: 'number', default: 60 }
        },
        init: function () {
          this.canvas = document.createElement('canvas');
          this.canvas.width = this.data.width;
          this.canvas.height = this.data.height;
          
          // Create segment display instance
          this.display = new SegmentDisplay(this.canvas.id);
          this.display.pattern = "###.##";
          this.display.cornerType = SegmentDisplay.RoundedCorner;
          this.display.displayAngle = 0;
          this.display.digitHeight = 40;
          this.display.digitWidth = 24;
          this.display.digitDistance = 3;
          this.display.segmentWidth = 4;
          this.display.segmentDistance = 0.5;
          this.display.colorOn = "rgba(255, 255, 0, 0.9)";
          this.display.colorOff = "rgba(255, 255, 0, 0.1)";
          
          // Create texture and material
          this.texture = new THREE.CanvasTexture(this.canvas);
          this.texture.needsUpdate = true;
          
          this.material = new THREE.MeshBasicMaterial({
            map: this.texture,
            transparent: true,
            alphaTest: 0.1,
            side: THREE.DoubleSide
          });
          
          // Create plane geometry
          const geometry = new THREE.PlaneGeometry(0.4, 0.12);
          this.mesh = new THREE.Mesh(geometry, this.material);
          this.el.setObject3D('mesh', this.mesh);
          
          this.updateDisplay();
        },
        update: function () {
          this.updateDisplay();
        },
        updateDisplay: function () {
          // Format value to ###.## pattern
          const numValue = parseFloat(this.data.value) || 0;
          const formattedValue = numValue.toFixed(2).padStart(6, ' ');
          
          // Update canvas directly since we don't have DOM element
          const context = this.canvas.getContext('2d');
          context.clearRect(0, 0, this.canvas.width, this.canvas.height);
          
          // Set canvas as display element temporarily
          const tempId = 'temp-display-' + Math.random().toString(36).substr(2, 9);
          this.canvas.id = tempId;
          document.body.appendChild(this.canvas);
          this.canvas.style.display = 'none';
          
          this.display.displayId = tempId;
          this.display.setValue(formattedValue);
          
          // Clean up
          document.body.removeChild(this.canvas);
          this.canvas.id = '';
          
          this.texture.needsUpdate = true;
        },
        remove: function () {
          if (this.material) {
            this.material.dispose();
          }
          if (this.texture) {
            this.texture.dispose();
          }
        }
      });

      // Simplified measure line component for Bollard Buddy
      AFRAME.registerComponent('measure-line', {
        schema: {
          start: { type: 'vec3', default: { x: 0, y: 0, z: 0 } },
          end: { type: 'vec3', default: { x: 0, y: 0, z: 0 } }
        },
        init: function () {
          this.tmpQuaternion = new THREE.Quaternion();
          this.direction = new THREE.Vector3();
          this.radius = 0.025;
          this.color = 0xffff00;
          this.endpointRadius = 0.075;
          this.startColor = 0x00ff00;
          this.endColor = 0xff0000;
          
          // Create canvas-based measurement display for AR compatibility
          this.labelEntity = document.createElement('a-entity');
          this.labelEntity.setAttribute('canvas-measurement-display', {
            value: '0.00'
          });
          this.el.appendChild(this.labelEntity);
        },
        update: function () {
          this.createOrUpdateHelper();
        },
        createOrUpdateHelper: function () {
          const start = this.data.start;
          const end = this.data.end;
          const length = this.calculateLength();
          
          // Create cylinder geometry
          const geometry = new THREE.CylinderGeometry(this.radius, this.radius, length, 8);
          
          if (!this.mesh) {
            const material = new THREE.MeshBasicMaterial({
              color: this.color,
              transparent: true,
              opacity: 0.7,
              depthTest: false
            });
            this.mesh = new THREE.Mesh(geometry, material);
            this.el.setObject3D('helper', this.mesh);
          } else {
            this.mesh.geometry.dispose();
            this.mesh.geometry = geometry;
          }
          
          // Position at midpoint
          this.mesh.position.set(
            (start.x + end.x) / 2,
            (start.y + end.y) / 2,
            (start.z + end.z) / 2
          );
          
          // Rotate to align with direction
          const up = new THREE.Vector3(0, 1, 0);
          this.direction.set(end.x - start.x, end.y - start.y, end.z - start.z).normalize();
          this.tmpQuaternion.setFromUnitVectors(up, this.direction);
          this.mesh.setRotationFromQuaternion(this.tmpQuaternion);
          
          this.createOrUpdateEndpoints(start, end);
          this.updateLabel(length);
        },
        createOrUpdateEndpoints: function (start, end) {
          const sphereGeometry = new THREE.SphereGeometry(this.endpointRadius, 16, 16);
          
          if (!this.startEndpoint) {
            const startMaterial = new THREE.MeshBasicMaterial({
              color: this.startColor,
              transparent: true,
              opacity: 0.8,
              depthTest: false
            });
            this.startEndpoint = new THREE.Mesh(sphereGeometry, startMaterial);
            this.el.setObject3D('startEndpoint', this.startEndpoint);
          }
          this.startEndpoint.position.set(start.x, start.y, start.z);
          
          if (!this.endEndpoint) {
            const endMaterial = new THREE.MeshBasicMaterial({
              color: this.endColor,
              transparent: true,
              opacity: 0.8,
              depthTest: false
            });
            this.endEndpoint = new THREE.Mesh(sphereGeometry, endMaterial);
            this.el.setObject3D('endEndpoint', this.endEndpoint);
          }
          this.endEndpoint.position.set(end.x, end.y, end.z);
        },
        updateLabel: function (length) {
          // Update canvas-based display value
          this.labelEntity.setAttribute('canvas-measurement-display', {
            value: length.toFixed(2)
          });
          
          // Position label at midpoint with offset
          const midpoint = new THREE.Vector3(
            (this.data.start.x + this.data.end.x) / 2,
            (this.data.start.y + this.data.end.y) / 2 + 0.3,
            (this.data.start.z + this.data.end.z) / 2
          );
          
          this.labelEntity.setAttribute('position', midpoint);
          
          // Make label always face the camera
          const camera = this.el.sceneEl.camera;
          if (camera) {
            this.labelEntity.setAttribute('look-at', camera);
          }
        },
        calculateLength: function () {
          const start = this.data.start;
          const end = this.data.end;
          const xDiff = end.x - start.x;
          const yDiff = end.y - start.y;
          const zDiff = end.z - start.z;
          return Math.sqrt(xDiff * xDiff + yDiff * yDiff + zDiff * zDiff);
        },
        remove: function () {
          if (this.mesh) {
            this.mesh.material.dispose();
            this.mesh.geometry.dispose();
          }
          if (this.startEndpoint) {
            this.startEndpoint.material.dispose();
            this.startEndpoint.geometry.dispose();
          }
          if (this.endEndpoint) {
            this.endEndpoint.material.dispose();
            this.endEndpoint.geometry.dispose();
          }
          if (this.labelEntity) {
            this.labelEntity.remove();
          }
        }
      });

      // VLaunch video frame capture component
      AFRAME.registerComponent('vlaunch-screenshot', {
        schema: {
          autoCapture: { type: 'boolean', default: false },
          interval: { type: 'number', default: 1000 }
        },
        init: function () {
          this.lastCapture = 0;
          this.videoTexture = null;
          
          // Create material for displaying captured frame
          const material = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            side: THREE.DoubleSide
          });
          
          // Apply material when loaded
          this.el.addEventListener('loaded', () => {
            const mesh = this.el.getObject3D('mesh');
            if (mesh) {
              mesh.material = material;
              this.material = material;
              console.log('VLaunch screenshot material applied');
            }
          });
          
          // Check if VLaunch is available
          this.checkVLaunchAvailability();
        },
        checkVLaunchAvailability: function () {
          if (typeof VLaunch !== 'undefined' && VLaunch.requestVideoFrame) {
            console.log('VLaunch.requestVideoFrame available');
            this.vlaunchAvailable = true;
          } else {
            console.log('VLaunch.requestVideoFrame not available - checking again in 1s');
            setTimeout(() => this.checkVLaunchAvailability(), 1000);
          }
        },
        tick: function (time, timeDelta) {
          if (!this.data.autoCapture || !this.vlaunchAvailable) return;
          
          if (time - this.lastCapture > this.data.interval) {
            this.captureFrame();
            this.lastCapture = time;
          }
        },
        captureFrame: function () {
          if (!this.vlaunchAvailable) {
            console.warn('VLaunch not available for video frame capture');
            return;
          }
          
          console.log('Requesting video frame from VLaunch...');
          
          VLaunch.requestVideoFrame((data) => {
            console.log('VLaunch video frame received:', data);
            
            if (data && data.data && data.format === 'base64Jpeg') {
              this.processVideoFrame(data);
            } else {
              console.warn('Unexpected video frame data format:', data);
            }
          });
        },
        processVideoFrame: function (frameData) {
          console.log('Processing video frame:', {
            width: frameData.width,
            height: frameData.height,
            format: frameData.format,
            dataLength: frameData.data.length
          });
          
          // Create image from base64 data
          const img = new Image();
          img.onload = () => {
            console.log('Video frame image loaded, creating texture');
            
            // Create or update texture
            if (!this.videoTexture) {
              this.videoTexture = new THREE.Texture(img);
              this.videoTexture.needsUpdate = true;
              
              if (this.material) {
                this.material.map = this.videoTexture;
                this.material.needsUpdate = true;
                console.log('Video frame texture applied to material');
              }
            } else {
              this.videoTexture.image = img;
              this.videoTexture.needsUpdate = true;
              console.log('Video frame texture updated');
            }
          };
          
          img.onerror = (error) => {
            console.error('Failed to load video frame image:', error);
          };
          
          // Set image source with base64 data
          img.src = `data:image/jpeg;base64,${frameData.data}`;
        },
        manualCapture: function () {
          console.log('Manual video frame capture triggered');
          this.captureFrame();
        },
        remove: function () {
          if (this.videoTexture) {
            this.videoTexture.dispose();
          }
          if (this.material) {
            this.material.dispose();
          }
        }
      });
    </script>
    <!-- <script src="https://unpkg.com/3dstreet@0.4.11/dist/aframe-street-component.js"></script> -->
    <script src="play.js"></script>

    <!-- <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-particle-system-component@1.1.4/dist/aframe-particle-system-component.min.js"></script> -->
  </head>
  <body>
    <a-scene
      vr-mode-ui="enterARButton: #play-button"
      device-orientation-permission-ui="enabled: false"
      webxr="requiredFeatures:hit-test,local-floor,dom-overlay;referenceSpaceType:local-floor;overlayElement:#overlay"
      metadata="lat: 37.766194; long: -122.412989; elevation: -26.5; title: AR Session Entities • Treat AR App"
      notify
    >
      <a-assets>
          <a-mixin
            shadow
            id="dividers-k71"
            gltf-model="src: url(https://assets.3dstreet.app/sets/uoregon/gltf-exports/draco/traffic-post-k71.glb)"
          ></a-mixin>
          <a-mixin
            shadow
            id="landscape-sunflower"
            gltf-model="src: url(https://cdn.glitch.me/b37e506f-65c9-49b0-b29e-ba5c75b8d553/sunflower.glb?v=1711151552432)"
          ></a-mixin>

          <a-mixin
          shadow
          id="temporary-traffic-cone"
          gltf-model="src: url(https://assets.3dstreet.app/sets/dividers/gltf-exports/draco/dividers-traffic-cone.glb)"
        ></a-mixin>

          <a-mixin
          shadow
          id="dividers-flowers"
          gltf-model="src: url(https://assets.3dstreet.app/sets/dividers/gltf-exports/draco/dividers-flowers.glb)"
        ></a-mixin>

          <a-mixin
          shadow
          id="bollard"
          gltf-model="src: url(https://assets.3dstreet.app/sets/dividers/gltf-exports/draco/dividers-bollard.glb)"
        ></a-mixin>

          <a-mixin
          shadow
          id="safehit"
          gltf-model="src: url(https://assets.3dstreet.app/sets/dividers/gltf-exports/draco/dividers-safehit.glb)"
        ></a-mixin>      
      </a-assets>
      <a-entity exit-ar-button="element: #exit-ar" hide-in-ar-mode></a-entity>
      <a-camera position="0 1.2 6"></a-camera>
      <a-ring
        id="reticle"
        ar-hit-test-simple
        rotation="-90 0 0"
        radius-inner="0.02"
        radius-outer="0.03"
      >
        <a-ring
          color="yellow"
          radius-inner="0.04"
          radius-outer="0.05"
          animation="property: scale; from: 1 1 1; to: 2 2 2; loop: true; dir: alternate"
        ></a-ring>
        <a-ring
          color="yellow"
          radius-inner="0.06"
          radius-outer="0.07"
          animation="property: scale; from: 1 1 1; to: 3 3 3; loop: true; dir: alternate"
        ></a-ring>
      </a-ring>
      <!-- Environment for 2D and VR viewing. It's auto-hidden in AR mode. -->
      <a-entity
        environment="preset: forest; lighting: none; shadow: none; lightPosition: 0 2.15 0"
        hide-in-ar-mode
      ></a-entity>

      <a-entity id="parent"></a-entity>


      <a-entity light="type: ambient; intensity: 0.5;"></a-entity>
      <a-light
        type="directional"
        light="castShadow: true;
                      shadowMapHeight: 1024;
                      shadowMapWidth: 1024;
                      shadowCameraLeft: -7;
                      shadowCameraRight: 5;
                      shadowCameraBottom: -5;
                      shadowCameraTop: 5;"
        id="light"
        target="model"
        position="-5 3 1.5"
      ></a-light>

      <!-- This shadow-receiving plane is only visible in AR mode. -->
      <a-plane
        height="15"
        width="15"
        position="0 0 0"
        rotation="-90 0 0"
        shadow="receive: true"
        ar-shadows="opacity: 0.3"
        visible="false"
        id="shadow-plane"
      ></a-plane>
    </a-scene>

    <div id="overlay" draggable="false">
      <span id="greeting"> Bollard Buddy AR from 3DStreet </span>
      <button id="exit-ar">SHARE and exit AR mode</button>
      <div
        id="play-button"
        onclick="compassPermission();"
        class="play-button"
      ></div>

      <div class="bottom-menu">
        <p>
          Selected item:
          <span id="selectedModel"><b>temporary-traffic-cone</b></span
          >; Compass: <span id="compass">x</span> <span id="tracking"></span>
        </p>
        <div id="menu" class="scrolling-wrapper">
          <!-- Menu buttons will be generated dynamically -->
        </div>
        
        <!-- Screenshot thumbnails gallery -->
        <div id="screenshot-gallery" style="
          display: flex;
          flex-wrap: wrap;
          gap: 5px;
          padding: 10px 0;
          max-height: 80px;
          overflow-y: auto;
          border-top: 1px solid rgba(255,255,255,0.2);
          margin-top: 10px;
        ">
          <!-- Thumbnails will be added here -->
        </div>
      </div>
    </div>

    <div id="text">
      <div class="header-layout">
        <img src="3D-St-stacked-128.png" alt="3D Street Logo" class="logo-3dstreet" />
        <img src="buddy.png" alt="Bollard Buddy Logo" class="logo-buddy" />
        <h1>Bollard Buddy:<br/>Place, Measure, View in AR</h1>
      </div>
      <p>An app from <a href="https://3dstreet.com" target="_blank">3DStreet</a>. For mobile WebXR compatible devices and browsers. Orientation default is North (-z)</p>
    </div>

    <div id="post" style="visibility: hidden">
      <h1>Bollard Buddy AR</h1>
      <h2>Wow beautiful creation! Here's a magic link for sharing:</h2>
      <input type="text" id="shareLink" name="shareLink" />
      <h1>
        <button id="share">SHARE</button>
      </h1>
    </div>
    <script>
      function compassPermission() {
        if (
          typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function"
        ) {
          // (optional) Do something before API request prompt.
          DeviceOrientationEvent.requestPermission()
            .then((response) => {
              // (optional) Do something after API prompt dismissed.

              if (response == "granted") {
                window.addEventListener("deviceorientation", (e) => {
                  // do something for 'e' here.

                  // log(e.alpha);
                  // console.log(e);

                  var compassHeading = 360 - e.alpha;
                  document.getElementById("compass").textContent =
                    compassHeading.toFixed(3) + "º";
                  // DeviceOrientationEvent
                  //                    log(Math.round(event.alpha));
                  // log(Math.round(event.beta));
                  // log(Math.round(event.gamma));
                });
              }
            })
            .catch(console.error);
        } else {
          alert("DeviceMotionEvent is not defined");
        }
      }
      
      window.addEventListener('vlaunch-initialized', (event) => {
        console.log('vlaunch-initialized', event);
        if (event.detail.browser === "launch-viewer") {

          // Debug: Test if the element exists
          setTimeout(() => {
            const trackingElement = document.getElementById('tracking');
            console.log('Tracking element found:', trackingElement);
            if (trackingElement) {
              trackingElement.textContent = 'Tracking: Initializing...';
            }
          }, 1000);
          
          // Add tracking quality event listener
          window.addEventListener('vlaunch-ar-tracking', function(event) {
            console.log('vlaunch-ar-tracking event received:', event);
            console.log('Event detail:', event.detail);
            
            const trackingStatus = event.detail.status;
            const trackingElement = document.getElementById('tracking');
            
            if (trackingElement) {
              // Display the tracking state
              trackingElement.textContent = 'Tracking: ' + trackingStatus;
            }
            console.log('Tracking quality changed:', trackingStatus);
          });
        }
        // then show tracking events
        
      })
      
      function getTrackingColor(state) {
        switch (state) {
          case 'normal':
            return '#00ff00'; // Green for good tracking
          case 'not-available':
            return '#ff0000'; // Red for no tracking
          case 'limited-excessive-motion':
          case 'limited-initializing':
          case 'limited-insufficient-features':
          case 'limited-relocalizing':
            return '#ffaa00'; // Orange for limited tracking
          default:
            return '#ffffff'; // White for unknown
        }
      }
    </script>
    <script>
      window.POINTERDOWN_STATUS = false; // default is false
      window.MEASURE_STATE = { 
        isActive: false, 
        startPoint: null, 
        currentMeasure: null 
      };
      
      function handleMeasureClick(position) {
        if (!window.MEASURE_STATE.isActive) {
          // First click - create measure line and set start point
          window.MEASURE_STATE.isActive = true;
          window.MEASURE_STATE.startPoint = {x: position.x, y: position.y, z: position.z};
          
          const measureId = "measure-" + Date.now();
          const measureEntity = document.createElement("a-entity");
          measureEntity.setAttribute("id", measureId);
          measureEntity.setAttribute("measure-line", {
            start: window.MEASURE_STATE.startPoint,
            end: window.MEASURE_STATE.startPoint // Start with same point
          });
          
          document.getElementById("parent").appendChild(measureEntity);
          window.MEASURE_STATE.currentMeasure = measureEntity;
          
          console.log("Measurement started at:", position);
        } else {
          // Second click - finalize measurement
          const endPoint = {x: position.x, y: position.y, z: position.z};
          
          if (window.MEASURE_STATE.currentMeasure) {
            window.MEASURE_STATE.currentMeasure.setAttribute("measure-line", {
              start: window.MEASURE_STATE.startPoint,
              end: endPoint
            });
          }
          
          // Reset state
          window.MEASURE_STATE.isActive = false;
          window.MEASURE_STATE.startPoint = null;
          
          console.log("Measurement completed:", window.MEASURE_STATE.startPoint, "to", endPoint);
        }
      }
      
      function handleCaptureClick(position) {
        console.log("Capture tool activated at:", position);
        
        // Prevent multiple captures by checking if one is already in progress
        if (window.CAPTURE_IN_PROGRESS) {
          console.log("Capture already in progress, ignoring");
          return;
        }
        
        window.CAPTURE_IN_PROGRESS = true;
        
        // Create purple sphere at capture location
        const captureId = "capture-" + Date.now();
        const captureEntity = document.createElement("a-entity");
        captureEntity.setAttribute("id", captureId);
        
        // Create purple sphere
        const sphereEntity = document.createElement("a-sphere");
        sphereEntity.setAttribute("radius", "0.05");
        sphereEntity.setAttribute("material", {
          color: "#8A2BE2",
          transparent: true,
          opacity: 0.8,
          metalness: 0.3,
          roughness: 0.7
        });
        sphereEntity.setAttribute("position", position);
        
        captureEntity.appendChild(sphereEntity);
        document.getElementById("parent").appendChild(captureEntity);
        
        console.log("Purple capture sphere placed");
        
        // Trigger screenshot capture
        if (typeof VLaunch !== 'undefined' && VLaunch.requestVideoFrame) {
          console.log("Requesting video frame...");
          
          let captureProcessed = false;
          VLaunch.requestVideoFrame((data) => {
            if (captureProcessed) {
              console.log("Ignoring duplicate VLaunch callback");
              return;
            }
            captureProcessed = true;
            
            if (data && data.data && data.format === 'base64Jpeg') {
              const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
              const filename = `capture-${timestamp}.jpg`;
              createARScreenshot(data, filename);
            } else {
              console.warn('Unexpected video frame data');
            }
            
            // Reset capture flag
            setTimeout(() => {
              window.CAPTURE_IN_PROGRESS = false;
            }, 1000);
          });
        } else {
          console.warn("VLaunch not available - using fallback");
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
          const filename = `capture-${timestamp}.png`;
          captureThreeJSCanvas(filename);
          
          // Reset capture flag
          setTimeout(() => {
            window.CAPTURE_IN_PROGRESS = false;
          }, 1000);
        }
      }
      
      
      function handleScreenshotClick(position) {
        console.log("Screenshot functionality triggered at:", position);
        
        if (typeof VLaunch !== 'undefined' && VLaunch.requestVideoFrame) {
          console.log("Taking AR screenshot...");
          
          VLaunch.requestVideoFrame((data) => {
            console.log("VLaunch video frame received for screenshot:", {
              width: data.width,
              height: data.height,
              format: data.format,
              dataLength: data.data.length
            });
            
            if (data && data.data && data.format === 'base64Jpeg') {
              createARScreenshot(data);
            } else {
              console.warn('Unexpected video frame data for screenshot:', data);
            }
          });
        } else {
          console.warn("VLaunch.requestVideoFrame not available for screenshot");
          // Fallback to just Three.js canvas capture
          captureThreeJSCanvas();
        }
      }
      
      function createARScreenshot(videoFrameData, filename = 'ar-screenshot.jpg') {
        console.log("Creating AR screenshot composite...");
        
        const scene = document.querySelector('a-scene');
        const renderer = scene.renderer;
        const canvas = renderer.domElement;
        
        // Create a temporary canvas for compositing
        const compositeCanvas = document.createElement('canvas');
        const ctx = compositeCanvas.getContext('2d');
        
        // Set canvas size to match video frame
        compositeCanvas.width = videoFrameData.width;
        compositeCanvas.height = videoFrameData.height;
        
        // Create image from base64 video frame
        const backgroundImg = new Image();
        backgroundImg.onload = () => {
          console.log("Background video frame loaded, compositing...");
          
          // Draw background (camera feed)
          ctx.drawImage(backgroundImg, 0, 0, compositeCanvas.width, compositeCanvas.height);
          
          // Create Three.js scene image
          const sceneImg = new Image();
          sceneImg.onload = () => {
            console.log("Three.js scene image loaded, final compositing...");
            
            // Draw Three.js scene on top with transparency
            ctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(sceneImg, 0, 0, compositeCanvas.width, compositeCanvas.height);
            
            // Convert to blob and download
            compositeCanvas.toBlob((blob) => {
              downloadScreenshot(blob, filename);
            }, 'image/jpeg', 0.9);
          };
          
          sceneImg.onerror = () => {
            console.warn("Failed to load Three.js canvas, saving background only");
            compositeCanvas.toBlob((blob) => {
              downloadScreenshot(blob, filename);
            }, 'image/jpeg', 0.9);
          };
          
          // Get Three.js canvas as image
          sceneImg.src = canvas.toDataURL('image/png');
        };
        
        backgroundImg.onerror = () => {
          console.error("Failed to load video frame for screenshot");
        };
        
        backgroundImg.src = `data:image/jpeg;base64,${videoFrameData.data}`;
      }
      
      function captureThreeJSCanvas(filename = 'ar-scene.png') {
        console.log("Capturing Three.js canvas only...");
        
        const scene = document.querySelector('a-scene');
        const canvas = scene.renderer.domElement;
        
        canvas.toBlob((blob) => {
          downloadScreenshot(blob, filename);
        }, 'image/png');
      }
      
      function downloadScreenshot(blob, filename) {
        console.log("📷 downloadScreenshot called:", filename);
        
        // Check if this filename is already being processed
        if (window.PROCESSING_SCREENSHOTS && window.PROCESSING_SCREENSHOTS.has(filename)) {
          console.log("Already processing this screenshot, skipping:", filename);
          return;
        }
        
        // Track processing screenshots
        if (!window.PROCESSING_SCREENSHOTS) {
          window.PROCESSING_SCREENSHOTS = new Set();
        }
        window.PROCESSING_SCREENSHOTS.add(filename);
        
        // Convert blob to base64 data URL 
        const reader = new FileReader();
        reader.onload = function() {
          const dataUrl = reader.result;
          
          // Add thumbnail to gallery (main functionality)
          addThumbnailToGallery(dataUrl, filename);
          
          // Remove from processing set after a delay
          setTimeout(() => {
            window.PROCESSING_SCREENSHOTS.delete(filename);
          }, 2000);
        };
        reader.readAsDataURL(blob);
      }
      
      function addThumbnailToGallery(dataUrl, filename) {
        console.log("Adding thumbnail to gallery:", filename);
        
        const gallery = document.getElementById("screenshot-gallery");
        if (!gallery) {
          console.warn("Screenshot gallery not found");
          return;
        }
        
        // Check if this filename already exists to prevent duplicates
        const existingThumbnails = gallery.querySelectorAll('img');
        for (let img of existingThumbnails) {
          if (img.dataset.filename === filename) {
            console.log("Thumbnail already exists, skipping:", filename);
            return;
          }
        }
        
        // Create thumbnail container
        const thumbnailContainer = document.createElement('div');
        thumbnailContainer.style.cssText = `
          position: relative;
          display: flex;
          flex-direction: column;
          align-items: center;
          margin: 2px;
        `;
        
        // Create thumbnail image
        const thumbnail = document.createElement('img');
        thumbnail.src = dataUrl;
        thumbnail.dataset.filename = filename; // Store filename for duplicate checking
        thumbnail.style.cssText = `
          width: 60px;
          height: 45px;
          object-fit: cover;
          border: 2px solid #8A2BE2;
          border-radius: 4px;
          cursor: pointer;
          transition: transform 0.2s;
        `;
        
        // Create timestamp label
        const timestamp = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const label = document.createElement('div');
        label.textContent = timestamp;
        label.style.cssText = `
          font-size: 10px;
          color: white;
          text-align: center;
          margin-top: 2px;
          background: rgba(0,0,0,0.5);
          padding: 1px 3px;
          border-radius: 2px;
        `;
        
        // Add hover effect
        thumbnail.addEventListener('mouseenter', () => {
          thumbnail.style.transform = 'scale(1.1)';
        });
        thumbnail.addEventListener('mouseleave', () => {
          thumbnail.style.transform = 'scale(1)';
        });
        
        // Add click to view full size
        thumbnail.addEventListener('click', () => {
          showFullSizeImage(dataUrl, filename);
        });
        
        thumbnailContainer.appendChild(thumbnail);
        thumbnailContainer.appendChild(label);
        
        // Add to gallery (newest last)
        gallery.appendChild(thumbnailContainer);
        
        // Limit to 10 thumbnails to prevent clutter
        while (gallery.children.length > 10) {
          gallery.removeChild(gallery.firstChild);
        }
        
        console.log("✅ Thumbnail added");
      }
      
      function showFullSizeImage(dataUrl, filename) {
        
        // Create full-size overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background: rgba(0,0,0,0.9);
          z-index: 10000;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          color: white;
          font-family: sans-serif;
        `;
        
        const img = document.createElement('img');
        img.src = dataUrl;
        img.style.cssText = `
          max-width: 90%;
          max-height: 80%;
          border: 2px solid white;
          border-radius: 8px;
        `;
        
        const title = document.createElement('div');
        title.textContent = filename;
        title.style.cssText = `
          margin: 20px;
          fontSize: 18px;
          text-align: center;
        `;
        
        const instructions = document.createElement('div');
        instructions.textContent = 'Long press image to save • Tap outside to close';
        instructions.style.cssText = `
          fontSize: 14px;
          opacity: 0.8;
          text-align: center;
        `;
        
        overlay.appendChild(title);
        overlay.appendChild(img);
        overlay.appendChild(instructions);
        
        // Close on click outside image
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) {
            document.body.removeChild(overlay);
          }
        });
        
        document.body.appendChild(overlay);
        
        // Auto-remove after 30 seconds
        setTimeout(() => {
          if (document.body.contains(overlay)) {
            document.body.removeChild(overlay);
          }
        }, 30000);
      }
      
      function share() {
        if (navigator.share) {
          navigator
            .share({
              title: "Bollard Buddy AR Scene",
              text: document.getElementById("shareLink").value,
            })
            .then(() => console.log("Successful share"))
            .catch((error) => console.log("Error sharing:", error));
        }
      }
      document.getElementById("share").onclick = share.bind(this);

      function setSelected(mixin) {
        document.getElementById("selectedModel").textContent = mixin;
        console.log(this);
        // Get a list of all the elements with the class "my-class"
        const elements = document.querySelectorAll(".card");

        // Iterate over the list and remove the class from each element
        elements.forEach((element) => element.classList.remove("selected"));
        this.classList.add("selected");
      }

      // Data-driven menu configuration
      const menuItems = [
        { id: "temporary-traffic-cone", label: "Cone" },
        { id: "measure-line", label: "Measure" },
        { id: "capture", label: "Capture" },
        { id: "bollard", label: "Bollard" },
        { id: "dividers-flowers", label: "Flowers" },
        { id: "safehit", label: "Delineator" },
        { id: "bench", label: "Bench" },
        { id: "lamp-traditional", label: "Lamp" },
        { id: "outdoor_dining", label: "Dining" }
      ];

      // Generate menu buttons dynamically
      const menuContainer = document.getElementById("menu");
      menuContainer.innerHTML = ""; // Clear existing buttons
      
      menuItems.forEach((item, index) => {
        const button = document.createElement("div");
        button.className = index === 0 ? "card selected" : "card";
        button.id = `btn_${index}`;
        button.innerHTML = `<h2>${item.label}</h2>`;
        button.onclick = setSelected.bind(button, item.id);
        menuContainer.appendChild(button);
      });
      document
        .getElementById("overlay")
        .addEventListener("pointerdown", (event) => {
          console.log("overlay-pointerdown");
          window.POINTERDOWN_STATUS = true;
          //   event.preventDefault();
        });
      document
        .getElementById("overlay")
        .addEventListener("pointerup", (event) => {
          console.log("overlay-pointerup");
          setTimeout(() => {
            window.POINTERDOWN_STATUS = false;
          }, 100);
        });
    </script>
    <script>
      <!-- https://github.com/stspanho/aframe-hit-test/blob/master/index.html -->
      AFRAME.registerComponent("ar-hit-test-simple", {
        init: function () {
          this.xrHitTestSource = null;
          this.viewerSpace = null;
          this.refSpace = null;

          this.el.sceneEl.renderer.xr.addEventListener("sessionend", (ev) => {
            this.viewerSpace = null;
            this.refSpace = null;
            this.xrHitTestSource = null;
          });
          this.el.sceneEl.renderer.xr.addEventListener("sessionstart", (ev) => {
            let session = this.el.sceneEl.renderer.xr.getSession();

            let element = this.el;
            session.addEventListener("select", function () {
              if (window.POINTERDOWN_STATUS) return;
              let position = element.getAttribute("position");
              document
                .getElementById("shadow-plane")
                .setAttribute("position", position);
              let newMixin =
                document.getElementById("selectedModel").textContent;
              
              if (newMixin === "measure-line") {
                handleMeasureClick(position);
                // Only show DONE button after completing measurement (second click)
                if (!window.MEASURE_STATE.isActive && window.MEASURE_STATE.currentMeasure) {
                  document.getElementById("text").style.visibility = "hidden";
                  document.getElementById("post").style.visibility = "visible";
                }
              } else if (newMixin === "capture") {
                handleCaptureClick(position);
                // Show DONE button
                document.getElementById("text").style.visibility = "hidden";
                document.getElementById("post").style.visibility = "visible";
              } else {
                placeElement(newMixin, position);
                // set DONE button to visible
                document.getElementById("text").style.visibility = "hidden";
                document.getElementById("post").style.visibility = "visible";
              }

              // Wait for A-Frame to fully initialize objects before getting child entities data
              setTimeout(() => {
                // Get the uncrushed child entities data
                var dataString = getChildEntitiesInfo(
                  document.getElementById("parent")
                );

                const queryParams = new URLSearchParams(document.location.search);
                const sceneMetadata = document
                  .querySelector("a-scene")
                  .getAttribute("metadata");

                // Get lat/long/elevation from either query params or scene metadata
                const lat = queryParams.get("lat") || sceneMetadata.lat;
                const long = queryParams.get("long") || sceneMetadata.long;
                const elevation = queryParams.get("elevation") || sceneMetadata.elevation;

                // Build the scene data structure
                let sceneData = {
                  title: "Bollard Buddy Session",
                  version: "0.5.5",
                  data: [
                    {
                      id: "street-container",
                      "data-layer-name": "User Layers",
                      components: {},
                      children: [                  {
                      "data-layer-name": "Bollard Buddy Session",
                      components: {},
                      children: dataString
                    }]
                    }
                    // {
                    //   id: "environment",
                    //   "data-layer-name": "Environment",
                    //   components: {"street-environment": ""}
                    // },
                    // {
                    //   id: "reference-layers",
                    //   "data-layer-name": "Geospatial Layers",
                    //   components: {
                    //     "street-geo": `longitude: ${long}; latitude: ${lat}; orthometricHeight: ${elevation};`
                    //   }
                    // }
                  ]
                };
                
                // local dev
                // document.getElementById("shareLink").value =
                //   "http://localhost:3333/#crushed-3dstreet-json:" +
                //   encodeURIComponent(window.JSONCrush.crush(JSON.stringify(sceneData)));

                // production
                document.getElementById("shareLink").value =
                  "https://3dstreet.app/#crushed-3dstreet-json:" +
                  encodeURIComponent(window.JSONCrush.crush(JSON.stringify(sceneData)));
              }, 500);
            });

            session.requestReferenceSpace("viewer").then((space) => {
              this.viewerSpace = space;
              session
                .requestHitTestSource({ space: this.viewerSpace })
                .then((hitTestSource) => {
                  this.xrHitTestSource = hitTestSource;
                });
            });

            session.requestReferenceSpace("local-floor").then((space) => {
              this.refSpace = space;
            });
          });
        },
        tick: function () {
          if (!this.viewerSpace) return;

          let frame = this.el.sceneEl.frame;
          let xrViewerPose = frame.getViewerPose(this.refSpace);

          if (this.xrHitTestSource && xrViewerPose) {
            let hitTestResults = frame.getHitTestResults(this.xrHitTestSource);
            if (hitTestResults.length > 0) {
              let pose = hitTestResults[0].getPose(this.refSpace);

              let inputMat = new THREE.Matrix4();
              inputMat.fromArray(pose.transform.matrix);

              let position = new THREE.Vector3();
              position.setFromMatrixPosition(inputMat);
              this.el.setAttribute("position", position);
              
              // Update measure line end point if in measurement mode
              if (window.MEASURE_STATE.isActive && window.MEASURE_STATE.currentMeasure) {
                const endPoint = {x: position.x, y: position.y, z: position.z};
                window.MEASURE_STATE.currentMeasure.setAttribute("measure-line", {
                  start: window.MEASURE_STATE.startPoint,
                  end: endPoint
                });
              }
            }
          }
        },
      });
    </script>
  </body>
</html>
